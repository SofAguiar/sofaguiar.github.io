[
  {
    "objectID": "ptbr/blog/survival-analysis.html",
    "href": "ptbr/blog/survival-analysis.html",
    "title": "Análise de Sobrevivência com Censura Intervalar",
    "section": "",
    "text": "Análise de Sobrevivência com Censura Intervalar\n\nO que é Análise de Sobrevivência?\nA Análise de Sobrevivência é um conjunto de técnicas estatísticas utilizadas para modelar o tempo até a ocorrência de um evento de interesse. Esses eventos podem ser falhas em sistemas mecânicos, tempo até a recidiva de uma doença, ou até mesmo a duração de um contrato de serviço. O diferencial da Análise de Sobrevivência em relação a outras técnicas estatísticas é a presença de censura, que ocorre quando o evento de interesse não é completamente observado.\n\n\nCensura intervalar\nA censura intervalar ocorre quando o tempo exato do evento não é conhecido, mas sabe-se que ele aconteceu dentro de um intervalo de tempo. Isso é comum em estudos médicos, nos quais os pacientes são avaliados periodicamente e o evento pode ter ocorrido entre duas consultas. Modelos tradicionais de Análise de Sobrevivência, como Kaplan-Meier e modelos de riscos proporcionais de Cox, não são adequados para lidar com esse tipo de censura, sendo necessário utilizar abordagens específicas, como as curvas de Turnbull e a extensão do modelo de Cox para censura intervalar.\n\n\nPasso a passo\n\nPreparo do ambiente\nPara realizar a análise, utilizamos o R e carregamos os pacotes necessários para manipulação de dados e modelagem estatística.\n\n# Carregando os pacotes necessários\n\nlibrary(tidyverse)   # Pacote para manipulação e visualização de dados\nlibrary(survival)    # Pacote para análise de sobrevivência\nlibrary(icenReg)     # Pacote para análise de sobrevivência com censura intervalar\n\n\n\nObtenção dos dados sintéticos\nCriamos um conjunto de dados sintético com 600 indivíduos e algumas variáveis de interesse, como uma variável categórica, uma variável contínua e o tempo até a ocorrência do evento de interesse. A construção dos dados leva em consideração a influência das variáveis na probabilidade de o evento ocorrer.\n\nn &lt;- 600 # Número de indivíduos na base de dados\n\n# Número de observações por indivíduo, variando entre 2 e 5 observações\nobs_por_individuo &lt;- sample(2:5, n, replace = TRUE)\n\n# Expandindo os IDs para refletir múltiplas observações por indivíduo\ndados &lt;- data.frame(\n  ID = rep(1:n, times = obs_por_individuo)\n)\n\ndados &lt;- dados %&gt;%\n  mutate(\n    # Variável categórica exemplo (var_cat)\n    var_cat = rep(sample(c(0, 1), n, replace = TRUE), times = obs_por_individuo),\n    \n    # Variável contínua exemplo (var_cont), que possui dependência da variável categórica\n    var_cont = unlist(lapply(var_cat, function(s) {\n      if (s == 1) {\n        sample(5500:8000, 1)  # Valor para 'var_cat' igual a 1 \n      } else {\n        sample(1800:3500, 1)  # Valor para 'var_cat' igual a 0 \n      }\n    })),\n    \n    # Idade atual dos indivíduos, gerada aleatoriamente entre 0 e 10 anos\n    idade_atual = unlist(lapply(obs_por_individuo, function(x) runif(x, min = 0, max = 10))),\n    \n    # Risco do desfecho com base em 'var_cat' e 'var_cont'\n    risco_desfecho  = 0.2 + var_cat * (-0.4) + var_cont * 0.0001\n  )\n# Gerando a variável 'desfecho' a partir do risco, usando 0.5 como valor de corte\ndados = dados %&gt;% \n  mutate(desfecho = ifelse(risco_desfecho&gt;0.5,1,0)) %&gt;% \n  select(-risco_desfecho) # remove o risco\n\n\n\nTransformação em dados de sobrevivência\nOs dados brutos precisam ser transformados em um formato adequado para análise de sobrevivência com censura intervalar. Criamos as variáveis left (limite inferior do tempo do evento) e right (limite superior do tempo do evento), bem como a variável de censura (cens), que indica se o evento foi observado (1) ou censurado (0).\n\ndf_surv = dados %&gt;% \n  group_by(ID) %&gt;% \n  summarise(\n    left = ifelse(\n      any(desfecho == 1),\n      max(idade_atual[idade_atual &lt; min(idade_atual[desfecho == 1], na.rm = T)\n                      & desfecho == 0], na.rm = T),\n      max(idade_atual) # Caso não tenha ocorrência do evento, a maior idade é registrada\n    ),\n    right = ifelse(any(desfecho == 1),\n                   min(idade_atual[desfecho == 1], na.rm = T),\n                   NA), # Caso o evento não tenha ocorrido, substitui por NA\n    cens = ifelse(any(desfecho == 1), 1, 0),  # Indica se o evento foi observado (1) ou censurado (0)\n    var_cat = first(var_cat),   # Variáveis de covariáveis para análise\n    var_cont = first(var_cont)\n  ) %&gt;% \n  ungroup() %&gt;% \n  mutate(left = ifelse(left &lt; 0, 0, left))  # Garante que 'left' não seja negativo\n\n\n\nCurvas de Turnbull\nAs curvas de Turnbull são uma extensão do estimador de Kaplan-Meier para dados com censura intervalar. Implementamos uma função para calcular o vetor de tempos ótimos (tau), estimar a função de sobrevivência inicial e iterativamente atualizar as probabilidades de sobrevivência até a convergência do algoritmo.\nComparamos as curvas de sobrevivência entre dois grupos da variável categórica para verificar diferenças na distribuição do tempo até o evento.\n\n# Função para criar o vetor de tempos (tau) a partir dos intervalos censurados\n# O uso de digitos de arrendondamento é contribuição de Sofia Aguiar \n# a fim de evitar erros em bases meiores que 10 mil\ncria.tau &lt;- function(data, digits = 6) {\n  l &lt;- data$left\n  r &lt;- data$right\n  \n  # Arredonda os valores para evitar pequenas diferenças numéricas\n  l &lt;- round(l, digits = digits)\n  r &lt;- round(r, digits = digits)\n  \n  tau &lt;- sort(unique(c(l, r[is.finite(r)])))  # Combina os tempos de censura\n  return(tau)\n}\n\n# Função para inicializar a função de sobrevivência com base no vetor tau\nS.ini &lt;- function(tau){\n  m&lt;-length(tau)\n  ekm&lt;-survfit(Surv(tau[1:m-1],rep(1,m-1))~1)\n  So&lt;-c(1,ekm$surv)\n  p &lt;- -diff(So)\n  return(p)\n}\n\n# Função para construir a matriz A de intervalos de censura\ncria.A &lt;- function(data,tau){\n  tau12 &lt;- cbind(tau[-length(tau)],tau[-1]) # Cria os intervalos [tau[i], tau[i+1]]\n  interv &lt;- function(x,inf,sup) ifelse(x[1]&gt;=inf & x[2]&lt;=sup,1,0)\n  A &lt;- apply(tau12,1,interv,inf=data$left,sup=data$right)\n  id.lin.zero &lt;- which(apply(A==0, 1, all)) # Matriz de censura\n  if(length(id.lin.zero)&gt;0) A &lt;- A[-id.lin.zero, ] # Filtra intervalos não observados\n  return(A)\n}\n\n# Função de Turnbull, que realiza a estimação iterativa da função de sobrevivência\nTurnbull &lt;- function(p, A, data, eps=1e-3,\n                     iter.max=200, verbose=FALSE){\n  n&lt;-nrow(A)\n  m&lt;-ncol(A)\n  Q&lt;-matrix(1,m)\n  iter &lt;- 0\n  repeat {\n    iter &lt;- iter + 1\n    diff&lt;- (Q-p)\n    maxdiff&lt;-max(abs(as.vector(diff))) # Diferença máxima entre iterações\n    if (verbose)\n      print(maxdiff)\n    if (maxdiff&lt;eps | iter&gt;=iter.max)\n      break\n    Q&lt;-p\n    C&lt;-A%*%p\n    p&lt;-p*((t(A)%*%(1/C))/n) # Atualiza as estimativas de probabilidade\n  }\n    cat(\"Iterations = \", iter,\"\\n\")\n    cat(\"Max difference = \", maxdiff,\"\\n\")\n    cat(\"Convergence criteria: Max difference &lt; 1e-3\",\"\\n\")\n  dimnames(p)&lt;-list(NULL,c(\"P Estimate\"))\n  surv&lt;-round(c(1,1-cumsum(p)),digits=5)\n  right &lt;- data$right\n   if(any(!(is.finite(right)))){\n    t &lt;- max(right[is.finite(right)])\n    return(list(time=tau[tau&lt;t],surv=surv[tau&lt;t]))\n  }\n  else\n    return(list(time=tau,surv=surv)) # Retorna a função de sobrevivência\n}\n\n\n# Estimação da função de sobrevivência para 'var_cat' igual a 0 e 1 \ndat1 = df_surv[df_surv$var_cat == 0,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb1 = Turnbull(p, A, dat1)\n\nIterations =  27 \nMax difference =  0.0009687948 \nConvergence criteria: Max difference &lt; 1e-3 \n\ndat1 = df_surv[df_surv$var_cat == 1,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb2 = Turnbull(p, A, dat1)\n\nIterations =  38 \nMax difference =  0.0009939516 \nConvergence criteria: Max difference &lt; 1e-3 \n\n# Visualização das funções de sobrevivência para os dois grupos\npar(mfrow = c(1, 1))\nplot(tb1$time, tb1$surv, col = \"red\", type = \"s\", ylim = c(0, 1), xlim = c(0, 10),\n     xlab = \"Tempo em anos\", ylab = \"S(t)\")\nlines(tb2$time, tb2$surv, col = \"blue\", type = \"s\")\nlegend(7.5, 0.9, lty = 1, col = c(\"red\", \"blue\"), c(\"Categoria 0\", \"Categoria 1\"),\n       bty = \"n\", cex = 0.9)\n\n\n\n\n\n\n\n\n\n\nExtensão do modelo de cox para censura intervalar\nO modelo de riscos proporcionais de Cox é amplamente utilizado em análise de sobrevivência, mas precisa ser adaptado para lidar com censura intervalar. Utilizamos o pacote icenReg para estimar os coeficientes do modelo de Cox estendido para censura intervalar. Ajustamos modelos univariados e multivariados para identificar quais variáveis estão associadas ao tempo até o evento.\n\nm = max(summary(df_surv$right))  # Máximo dos valores de censura\nli = df_surv$left \nui = ifelse(is.na(df_surv$right), m + 1000, df_surv$right)  # Ajuste para censura direita\n\n# Ajuste do modelo de Cox para a variável categórica\nfit1 = ic_sp(cbind(li, ui) ~ var_cat, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit1)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n        Estimate Exp(Est) Std.Error z-value       p\nvar_cat   0.1919    1.211    0.1013   1.894 0.05817\n\nfinal llk =  -921.9946 \nIterations =  30 \nBootstrap Samples =  100 \n\n# Ajuste do modelo de Cox para a variável contínua\nfit2 = ic_sp(cbind(li, ui) ~ var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit2)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cont, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n          Estimate Exp(Est) Std.Error z-value         p\nvar_cont 0.0001206        1 2.198e-05   5.489 4.036e-08\n\nfinal llk =  -911.2863 \nIterations =  31 \nBootstrap Samples =  100 \n\n# Seleção das variáveis com p-valor &lt; 0,25 para a análise multivariada\nfit3 = ic_sp(cbind(li, ui) ~ var_cat + var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit3)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat + var_cont, data = df_surv, \n    model = \"ph\", bs_samples = 100)\n\n           Estimate Exp(Est) Std.Error z-value         p\nvar_cat  -3.2280000  0.03965 4.092e-01  -7.889 3.109e-15\nvar_cont  0.0008609  1.00100 9.675e-05   8.898 0.000e+00\n\nfinal llk =  -866.0241 \nIterations =  26 \nBootstrap Samples =  100 \n\n\n\n\nSeleção de variáveis\nPara selecionar as variáveis mais relevantes, utilizamos um procedimento iterativo baseado na log-verossimilhança. Variáveis com baixa contribuição para o modelo podem ser removidas para simplificar a interpretação dos resultados e reduzir o sobreajuste.\n\nstep_icph &lt;- function(model, data) {\n  vars &lt;- attr(terms(model$formula), \"term.labels\")  # Variáveis do modelo\n  current_model &lt;- model\n  best_llk &lt;- current_model$llk  # Log-verossimilhança inicial\n  \n  # Processo iterativo de remoção de variáveis com base na log-verossimilhança\n  for (var in vars) {\n    formula_new &lt;- as.formula(paste(\"cbind(li, ui) ~\", \n                                    paste(setdiff(vars, var), collapse = \" + \")))\n    model_new &lt;- ic_sp(formula_new, model = \"ph\", bs_samples = 100, data = data)\n    new_llk &lt;- model_new$llk  # Log-verossimilhança do novo modelo\n    \n    # Diagnóstico e atualização do modelo\n    if (new_llk &gt; best_llk) {\n      best_llk &lt;- new_llk\n      current_model &lt;- model_new\n      vars &lt;- setdiff(vars, var)\n    }\n  }\n  \n  return(current_model)  # Retorna o modelo final\n}\n\n\n\n\nConclusão\nA análise de sobrevivência com censura intervalar permite estudar fenômenos nos quais o tempo exato do evento é desconhecido, mas delimitado dentro de um intervalo. O uso das curvas de Turnbull e da extensão do modelo de Cox para censura intervalar são ferramentas fundamentais para extrair informações valiosas desses dados. A seleção cuidadosa de variáveis melhora a precisão dos modelos e ajuda a compreender os fatores que influenciam o tempo até o evento de interesse.\n\n\nReferências\nANDERSON-BERGMAN, C. icenReg: Regression models for interval censored data in R. Versão 2.0. Disponível em: https://cran.r-project.org/package=icenReg. Acesso em: 19 dez. 2024\nCOLOSIMO, E. A.; GIOLO, S. R. Análise de sobrevivência aplicada. Blücher, 2024.\nSUN, Y. Survival data analysis with interval-censored data. Statistics in Medicine, v. 25, p. 3563-3578, 2006.\nTHERNEAU, T. M. survival: Survival Analysis, Including Penalised Likelihood (versão 3.4-0). 2023. Disponível em: https://cran.r-project.org/web/packages/survival/index.html. Acesso em: 16 dez. 2024.\nTURNBULL, B. W. The empirical distribution function with arbitrarily grouped, censored and truncated data. Journal of the Royal Statistical Society, v. 38, p. 290-295, 1976."
  },
  {
    "objectID": "ptbr/about.html",
    "href": "ptbr/about.html",
    "title": "É um prazer te ver por aqui!",
    "section": "",
    "text": "É um prazer te ver por aqui!\nSou Sofia Aguiar, graduanda em Estatística pela UFMG, com interesse em saúde pública e epidemiologia. Minha pesquisa busca transformar dados em ferramentas que fortaleçam o sistema de saúde e auxiliem profissionais na tomada de decisões.\nTenho experiência com visualização de dados, inferência estatística e programação em R. Atualmente, estou me aprofundando em métodos bayesianos, aprendizado de máquina e Python para expandir minhas análises e modelagens preditivas.\n\n📬 Contato:\nMe envie um e-mail em sof.m.aguiar@gmail.com\n\n\n📌 Onde me encontrar:\n\nProjetos de programação: GitHub\nCurrículo acadêmico: Lattes\nPerfil acadêmico: OrcID\n\n\n\nMeus projetos favoritos\n\nAnálise de Sobrevivência Intervalar - Uma aplicação dos métodos de análise de sobrevivência intervalar com banco de dados sintético.\n\n\n\nTutoriais em R para pesquisadores\n\nAnálise Exploratória - Um breve passo a passo de como olhar para seu dataset\n\n\nAviso: Este site está em desenvolvimento. Mudanças podem ocorrer!"
  },
  {
    "objectID": "en/blog/data-viz.html",
    "href": "en/blog/data-viz.html",
    "title": "How to visualize your database - creating beautiful graphs and tables",
    "section": "",
    "text": "Warning! The translation is still in progress, this is an automatic translation and it may not be correct\n\n\nHow to visualize your database - creating beautiful graphs and tables\nA well-done descriptive and exploratory analysis can often change the course of your research. This is the ideal time to think about your research objective, the scope of your work, and the main information you should pay attention to.\nIn this tutorial, we will use the database available through Kaggle here. It describes more than 9,000 medical records of patients associated with the risk of diabetes.\n\nFirst of all, prepare the environment\nIn programming, having the code organized is essential. Both so that you can return to the analyses you did and understand what was done, and so that you can collaborate with other researchers.\nWe will start by configuring our environment, loading the necessary packages and other settings.\n\n# Packages used\n# This structure loads and installs packages if they are not already installed\nif(!require(tidyverse)) install.packages(\"tidyverse\")\nif(!require(kableExtra)) install.packages(\"kableExtra\")\nif(!require(ggcorrplot)) install.packages(\"ggcorrplot\")\nif(!require(corrr)) install.packages(\"corrr\")\nif(!require(rstatix)) install.packages(\"rstatix\")\n\n# For possible variables with very small or very large values, this option\n# avoids scientific notation\noptions(scipen = 9999)\n\n\n\nLoad your database\nFor databases on platforms like Kagle, there are n ways to load the database besides the traditional download and upload of the file. In my case, I downloaded the database and uploaded it to the website’s GitHub since I’ll be using the same dataset several times.\n\n# Browse through the folders and load the database in .csv\ndiabetes_dataset = read.csv(\"../../assets/datasets/diabetes_dataset.csv\")\n\nBefore performing any analysis, we need to check the database. Ask yourself a few questions:\n\nWere all the columns read correctly?\nWere the decimal places set correctly?\nWhat are the types of each column?\nAre the characters set correctly?\n\nTo answer this, two simple commands and a little knowledge of what each variable means are enough.\n\n# Shows each column, the type and the first observations\nglimpse(diabetes_dataset)\n\nRows: 9,538\nColumns: 17\n$ Age                &lt;int&gt; 69, 32, 89, 78, 38, 41, 20, 39, 70, 19, 47, 55, 19,…\n$ Pregnancies        &lt;int&gt; 5, 1, 13, 13, 8, 10, 16, 4, 3, 1, 8, 0, 15, 12, 6, …\n$ BMI                &lt;dbl&gt; 28.39, 26.49, 25.34, 29.91, 24.56, 17.47, 15.76, 28…\n$ Glucose            &lt;dbl&gt; 130.1, 116.5, 101.0, 146.0, 103.2, 67.0, 61.6, 105.…\n$ BloodPressure      &lt;dbl&gt; 77, 72, 82, 104, 74, 71, 60, 94, 90, 62, 93, 87, 60…\n$ HbA1c              &lt;dbl&gt; 5.4, 4.5, 4.9, 5.7, 4.7, 4.2, 4.0, 4.5, 4.0, 4.0, 4…\n$ LDL                &lt;dbl&gt; 130.4, 87.4, 112.5, 50.7, 102.5, 105.3, 62.4, 91.0,…\n$ HDL                &lt;dbl&gt; 44.0, 54.2, 56.8, 39.1, 29.1, 58.8, 43.4, 50.1, 51.…\n$ Triglycerides      &lt;dbl&gt; 50.0, 129.9, 177.6, 117.0, 145.9, 140.7, 64.6, 195.…\n$ WaistCircumference &lt;dbl&gt; 90.5, 113.3, 84.7, 108.9, 84.1, 81.8, 66.5, 123.2, …\n$ HipCircumference   &lt;dbl&gt; 107.9, 81.4, 107.2, 110.0, 92.8, 93.2, 102.7, 121.4…\n$ WHR                &lt;dbl&gt; 0.84, 1.39, 0.79, 0.99, 0.91, 0.88, 0.65, 1.01, 0.7…\n$ FamilyHistory      &lt;int&gt; 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, …\n$ DietType           &lt;int&gt; 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 1, 1, …\n$ Hypertension       &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ MedicationUse      &lt;int&gt; 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, …\n$ Outcome            &lt;int&gt; 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, …\n\n\n\n# Shows the first 6 rows of the database\nhead(diabetes_dataset)\n\n  Age Pregnancies   BMI Glucose BloodPressure HbA1c   LDL  HDL Triglycerides\n1  69           5 28.39   130.1            77   5.4 130.4 44.0          50.0\n2  32           1 26.49   116.5            72   4.5  87.4 54.2         129.9\n3  89          13 25.34   101.0            82   4.9 112.5 56.8         177.6\n4  78          13 29.91   146.0           104   5.7  50.7 39.1         117.0\n5  38           8 24.56   103.2            74   4.7 102.5 29.1         145.9\n6  41          10 17.47    67.0            71   4.2 105.3 58.8         140.7\n  WaistCircumference HipCircumference  WHR FamilyHistory DietType Hypertension\n1               90.5            107.9 0.84             0        0            0\n2              113.3             81.4 1.39             0        0            0\n3               84.7            107.2 0.79             0        0            0\n4              108.9            110.0 0.99             0        0            0\n5               84.1             92.8 0.91             0        1            0\n6               81.8             93.2 0.88             1        0            0\n  MedicationUse Outcome\n1             1       0\n2             0       0\n3             1       0\n4             1       1\n5             0       0\n6             0       1\n\n\nAll right! We can continue.\n\n\nReading the dictionary\nThe last step before a good descriptive and exploratory analysis is reading the dictionary of variables. This is essential to understand acronyms that may be in another language, check the unit of measurement of each variable and identify the type of each column.\n\nAge: Age of the individual (18-90 years).\nPregnancies: Number of times the patient has been pregnant.\nBMI (Body Mass Index - BMI): Measurement of body fat based on height and weight (kg/m²).\nGlucose: Blood glucose concentration (mg/dL), a key indicator of diabetes.\nBlood Pressure: Systolic blood pressure (mmHg), high levels may indicate hypertension.\nHbA1c: Glycated hemoglobin level (%), representing the average blood sugar level over several months.\nLDL (Low-Density Lipoprotein): Level of “bad” cholesterol (mg/dL).\nHDL (High-Density Lipoprotein): Level of “good” cholesterol (mg/dL).\nTriglycerides: Levels of fat in the blood (mg/dL), high values ​​increase the risk of diabetes.\nWaist Circumference: Waist measurement (cm), indicator of central obesity. - Hip Circumference (HipCircumference): Hip measurement (cm), used to calculate the waist-to-hip ratio.\nWaist-to-Hip Ratio (WHR): Waist circumference divided by hip circumference.\nFamily History (FamilyHistory): Indicates whether the individual has a family history of diabetes (1 = Yes, 0 = No).\nDiet Type (DietType): Eating habits (0 = Unbalanced, 1 = Balanced, 2 = Vegan/Vegetarian).\nHypertension (Hypertension): Presence of high blood pressure (1 = Yes, 0 = No).\nMedication Use (MedicationUse): Indicates whether the individual uses medication (1 = Yes, 0 = No).\nOutcome: Diagnosis of diabetes (1 = Diabetes, 0 = No Diabetes).\n\n\n\nUnivariate Analysis\nWe finally get to the stage of creating graphs and tables. An important piece of knowledge is knowing how to distinguish continuous variables (numbers and measurements) from categorical variables (classifications of some kind, such as race and sex).\nFor continuous variables, summary measures in a single table are an excellent way to add information to a report. For you, the researcher, to understand your database, creating histograms is a great way to visualize what is happening with each column, and to notice outliers and asymmetries.\n\n\nUnivariate Analysis\nWe finally get to the stage of creating graphs and tables. An important piece of knowledge is knowing how to distinguish continuous variables (numbers and measurements) from categorical variables (classifications of some kind, such as race and sex).\nFor continuous variables, summary measurements in a single table are an excellent way to add information to a report. For you, the researcher, to understand your database, creating histograms is a great way to visualize what is happening with each column, and to notice outliers and asymmetry, even if you don’t include them in the report.\nSo, to run the histogram, I recommend using the ggplot2 package, which provides a beautiful graph with relatively little effort.\n\ndiabetes_dataset %&gt;% # Opens the database\nselect(WaistCircumference) %&gt;% # Selects the variable of interest\nggplot(aes(x = WaistCircumference)) + # Calls the function to create graphs by placing our var on the x axis\ngeom_histogram(fill = \"#F2C354\", color = \"white\") + # Creates the histogram with the desired colors\nlabs(title = \"Histogram for Waist Circumference in cm\", # Adds title\nx = \"Waist Circumference (cm)\", # And replaces the default text on the axes\ny = \"Frequency\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nAnd now for our table we will need a little more code.\n\n# We define the labels in Portuguese for each categorical variable\nrotulos_categoricas &lt;- c( FamilyHistory = \"Family History\", # Indicates whether the individual has a family history of diabetes (1 = Yes, 0 = No)\nDietType = \"Diet Type\", # Eating habits (0 = Unbalanced, 1 = Balanced, 2 = Vegan/Vegetarian)\nHypertension = \"Hypertension\", # Presence of high blood pressure (1 = Yes, 0 = No)\nMedicationUse = \"Use of Medications\", # Indicates whether the individual uses medication (1 = Yes, 0 = No)\nOutcome = \"Result\" # Diagnosis of diabetes (1 = Diabetes, 0 = No Diabetes)\n)\n# We select only the categorical variables based on the defined labels\nvariaveis_categoricas &lt;- names(rotulos_categoricas)\n\n# Calculate the frequency and proportion for each category of categorical variables\nresumo_categoricas &lt;- diabetes_dataset %&gt;% # Access the dataset\nselect(all_of(variaveis_categoricas)) %&gt;% # Select the categorical columns\npivot_longer(cols = everything(), names_to = \"Variável\", values_to = \"Categoria\") %&gt;% # Convert the wide format to long\ngroup_by(Variável,Categoria) %&gt;% # Groups by unique values ​​of categorical variables\nsummarise(Frequency = n(), .groups = \"drop\") %&gt;% # Counts how many times each category appears\nmutate(Proportion = Frequency / sum(Frequency) * 100) %&gt;% # Calculates the relative percentage of each category\nmutate(Variável = recode(Variável, !!!rotulos_categoricas)) # Replaces the variable names with the labels in Portuguese\n\n# Let's create the table formatted\nresumo_categoricas %&gt;% # Calls the created summary\nkable(\"html\",\ncaption = \"Distribution of categorical variables\", # Uses kable from the kableExtra library\nalign = \"c\", # Aligns the text to the center\ncol.names = c(\"Variable\", \"Category\", \"Frequency\", \"Proportion (%)\")) %&gt;% # Defines the column names\nkable_styling(full_width = FALSE,\nbootstrap_options = c(\"striped\", \"hover\")) %&gt;% # Applies style settings\nfootnote(general = \"Source: Prepared by the author.\", # Adds the table font\ngeneral_title = \"\") %&gt;%\nadd_header_above(c(\" \" = 1, \"Descriptive Statistics\" = 3)) # Adds a header for the statistics columns\n\n\nDistribution of categorical variables\n\n\n\n\n\n\n\n\n\n\nDescriptive Statistics\n\n\n\nVariable\nCategory\nFrequency\nProportion (%)\n\n\n\n\nDiet Type\n0\n5794\n12.1492975\n\n\nDiet Type\n1\n2851\n5.9781925\n\n\nDiet Type\n2\n893\n1.8725100\n\n\nFamily History\n0\n6653\n13.9505137\n\n\nFamily History\n1\n2885\n6.0494863\n\n\nHypertension\n0\n9528\n19.9790312\n\n\nHypertension\n1\n10\n0.0209688\n\n\nUse of Medications\n0\n5675\n11.8997693\n\n\nUse of Medications\n1\n3863\n8.1002307\n\n\nResult\n0\n6256\n13.1180541\n\n\nResult\n1\n3282\n6.8819459\n\n\n\n Source: Prepared by the author.\n\n\n\n\n\n\n\n\n\n\n\nFor other formatting, just search a little in the package documentation kableExtra and understand what needs to be changed.\nFor categorical variables, the process is very similar. We will create a bar chart (never a pie chart!!) and a table with the summary measures.\n\ndiabetes_dataset %&gt;% # Opens the database\nselect(FamilyHistory) %&gt;% # Selects the variable of interest\nggplot(aes(x = as.factor(FamilyHistory))) + # Calls the function to create graphs by placing our var on the x axis as a factor (i.e. categorical var)\ngeom_bar(fill = \"#C97064\", color = \"white\") + # Creates the bar graph with the desired colors\nlabs(title = \"Distribution for Family History of Diabetes\", # Adds title\nx = \"Do you have a family history? (0 = no, 1 = yes)\", # And replaces the default text on the axes\ny = \"Frequency\")\n\n\n\n\n\n\n\n\nIt may also be interesting to create a graph for the group proportions on the y axis, in order to facilitate visualization. Just change a few lines of code as seen below.\n\ndiabetes_dataset %&gt;% # Open the database\ncount(FamilyHistory) %&gt;% # Count the occurrences of each category\nmutate(Proportion = n / sum(n)) %&gt;% # Calculate the proportion\nggplot(aes(x = as.factor(FamilyHistory), y = Proportion)) + # Set the axes\ngeom_col(fill = \"#68A357\", color = \"white\") + # Create the bar chart\nlabs(title = \"Distribution of Family History of Diabetes\", # Add title\nx = \"Do you have a family history? (0 = no, 1 = yes)\", # And replace the default text on the axes\ny = \"Proportion\")\n\n\n\n\n\n\n\n\nFinally, now let’s make the tables for the categorical variables.\n\n# We define the labels in Portuguese for each categorical variable\nrotulos_categoricas &lt;- c(\nFamilyHistory = \"Family History\", # Indicates whether the individual has a family history of diabetes (1 = Yes, 0 = No)\nDietType = \"Diet Type\", # Eating habits (0 = Unbalanced, 1 = Balanced, 2 = Vegan/Vegetarian)\nHypertension = \"Hypertension\", # Presence of high blood pressure (1 = Yes, 0 = No)\nMedicationUse = \"Use of Medications\", # Indicates whether the individual uses medication (1 = Yes, 0 = No)\nOutcome = \"Resultado\" # Diagnosis of diabetes (1 = Diabetes, 0 = No Diabetes)\n)\n# We select only the categorical variables based on the defined labels\nvariaveis_categoricas &lt;- names(rotulos_categoricas)\n\n# Calculate the frequency and proportion for each category of categorical variables\nresumo_categoricas &lt;- diabetes_dataset %&gt;% # Access the dataset\nselect(all_of(variaveis_categoricas)) %&gt;% # Select the categorical columns\npivot_longer(cols = everything(), names_to = \"Variável\", values_to = \"Categoria\") %&gt;% # Convert the wide format to long\ngroup_by(Variável,Categoria) %&gt;% # Groups by unique values of categorical variables\nsummarise(Frequency = n(), .groups = \"drop\") %&gt;% # Counts how many times each category appears\nmutate(Proporção = Frequency / sum(Frequency) * 100) %&gt;% # Calculates the relative percentage of each category\nmutate(Variável = recode(Variável, !!!rotulos_categoricas)) # Replaces the variable names with the labels in Portuguese\n\n# We adjusted to remove the repetition of the name of the variable\nresumo_categoricas &lt;- resumo_categoricas %&gt;%\ngroup_by(Variável) %&gt;%\nmutate(Variável = ifelse(row_number() == 1, Variável, \"\")) %&gt;% # Keeps the name only in the first line of each group\nungroup()\n\n# We create the formatted table\nresumo_categoricas %&gt;% # Calls the created summary\nkable(\"html\",\ncaption = \"Distribution of categorical variables\", # Uses kable from the kableExtra library\nalign = \"c\", # Aligns the text to the center\ncol.names = c(\"Variable\", \"Category\", \"Frequency\", \"Proportion (%)\")) %&gt;% # Defines the column names\nkable_styling(full_width = FALSE,\nbootstrap_options = c(\"striped\", \"hover\")) %&gt;% # Applies style settings\nfootnote(general = \"Source: Prepared by the author.\", # Add the table source\ngeneral_title = \"\") %&gt;%\nadd_header_above(c(\" \" = 1, \"Descriptive Statistics\" = 3)) # Add a header for the statistics columns\n\n\nDistribution of categorical variables\n\n\n\n\n\n\n\n\n\n\nDescriptive Statistics\n\n\n\nVariable\nCategory\nFrequency\nProportion (%)\n\n\n\n\nDiet Type\n0\n5794\n12.1492975\n\n\n\n1\n2851\n5.9781925\n\n\n\n2\n893\n1.8725100\n\n\nFamily History\n0\n6653\n13.9505137\n\n\n\n1\n2885\n6.0494863\n\n\nHypertension\n0\n9528\n19.9790312\n\n\n\n1\n10\n0.0209688\n\n\nUse of Medications\n0\n5675\n11.8997693\n\n\n\n1\n3863\n8.1002307\n\n\nResultado\n0\n6256\n13.1180541\n\n\n\n1\n3282\n6.8819459\n\n\n\n Source: Prepared by the author.\n\n\n\n\n\n\n\n\n\n\n\n\n\nBivariate analysis\nUnivariate analysis aims to understand the distribution of the variable itself. In bivariate (and multivariate) analysis, we want to understand the relationship between the variables. Note that I am not looking for causality or the predictive value of each variable; this will be a later step depending on your research objective.\nWe can start with a correlogram, which shows a map of the correlations of all continuous variables. It is very useful for identifying whether there is any collinearity between variables, which should be confirmed later through appropriate tests.\n\n# Select only continuous variables\ncontinuous_variables &lt;- c(\"Age\", \"BMI\", \"Glucose\", \"BloodPressure\", \"HbA1c\",\n\"LDL\", \"HDL\", \"Triglycerides\", \"WaistCircumference\",\n\"HipCircumference\", \"WHR\")\n\n# Create the correlation matrix\ncorrelation_matrix &lt;- diabetes_dataset %&gt;%\nselect(all_of(continuous_variables)) %&gt;% # Select only continuous variables\ncor(use = \"pairwise.complete.obs\") # Calculate the correlation excluding NA values\n\n# Create the correlogram\nggcorrplot(correlation_matrix,\nmethod = \"circle\", # Set the graph style (circles)\ntype = \"lower\", # Show only the lower half of the matrix\nlab = TRUE, # Show the correlation values\nlab_size = 3, # Size from the font of the labels\ncolors = c(\"#6D9EC1\", \"white\", \"#E46726\"), # Sets the color palette\ntitle = \"Correlogram of Continuous Variables\", # Adds a title\nggtheme = theme_minimal()) # Applies a minimalist theme\n\n\n\n\n\n\n\n\nAnother very important form of correlation, especially for prediction studies, is the correlation of each variable with the outcome.\n\n# We define continuous and categorical variables\ncontinuous_variables &lt;- c(\"Age\", \"BMI\", \"Glucose\", \"BloodPressure\", \"HbA1c\",\n\"LDL\", \"HDL\", \"Triglycerides\", \"WaistCircumference\",\n\"HipCircumference\", \"WHR\")\n\ncategorical_variables &lt;- c(\"FamilyHistory\", \"DietType\", \"Hypertension\",\n\"MedicationUse\")\n\n# --- Correlation for continuous variables with Outcome ---\ncontinuous_correlations &lt;- diabetes_dataset %&gt;%\nselect(all_of(continuous_variables), Outcome) %&gt;%\ncor(use = \"pairwise.complete.obs\") %&gt;%\nas.data.frame() %&gt;%\nselect(Outcome) %&gt;%\nrownames_to_column(var = \"Variable\") %&gt;%\nrename(`Correlation` = Outcome) %&gt;% # Rename for consistency\nmutate(Type = \"Continuous\")\n\n# --- Correlation for categorical variables with Outcome ---\ncalcular_cramer &lt;- function(var) {\ntab &lt;- table(diabetes_dataset[[var]], diabetes_dataset$Outcome)\ncramer &lt;- rstatix::cramer_v(tab) %&gt;% as.numeric() # Convert to number\nreturn(data.frame(Variable = var, `Correlation` = cramer, Type = \"Categorical\"))\n}\ncategorical_correlations &lt;- bind_rows(lapply(categorical_variables, calcular_cramer))\n\nWarning in stats::chisq.test(x, y, correct = correct, ...): Aproximação do\nqui-quadrado pode estar incorreta\n\n# --- We join all correlations ---\ntotal_correlations &lt;- bind_rows(continuous_correlations, categorical_correlations) %&gt;%\narrange(desc(abs(Correlation))) # Sort by the strength of the correlation\n\n# We define the labels in Portuguese for all variables\nlabels &lt;- c(\nAge = \"Age (years)\",\nBMI = \"Body Mass Index (kg/m²)\",\nGlucose = \"Glucose (mg/dL)\",\nBloodPressure = \"Blood Pressure (mmHg)\",\nHbA1c = \"Glycated Hemoglobin (%)\",\nLDL = \"LDL Cholesterol (mg/dL)\",\nHDL = \"HDL Cholesterol (mg/dL)\",\nTriglycerides = \"Triglycerides (mg/dL)\",\nWaistCircumference = \"Waist Circumference (cm)\",\nHipCircumference = \"Hip Circumference (cm)\",\nWHR = \"Waist-to-Hip Ratio\", FamilyHistory = \"Family History\",\nDietType = \"Diet Type\",\nHypertension = \"Hypertension\",\nMedicationUse = \"Medication Use\"\n)\n\n# Remove the correlation of Outcome with itself\ntotal_correlations &lt;- total_correlations %&gt;%\nfilter(Variable != \"Outcome\") %&gt;%\nmutate(Variable = recode(Variable, !!!labels)) # Apply labels\n\n# Display the formatted table\ntotal_correlations %&gt;%\nmutate(Correlation = round(Correlation, 3)) %&gt;% # Round values\nkable(\"html\",\ncaption = \"Correlation of All Variables with Outcome\",\nalign = \"c\",\ncol.names = c(\"Variable\", \"Correlation\", \"Type\")) %&gt;% # Define column names\nkable_styling(full_width = FALSE,\nbootstrap_options = c(\"striped\", \"hover\")) %&gt;% # Styling\nfootnote(general = \"Source: Prepared by the author.\",\ngeneral_title = \"\") %&gt;%\nadd_header_above(c(\" \" = 1, \"Correlation with Outcome\" = 2)) # Top header\n\n\nCorrelation of All Variables with Outcome\n\n\n\n\n\n\n\n\n\nCorrelation with Outcome\n\n\n\nVariable\nCorrelation\nType\n\n\n\n\nFamily History\n0.909\nCategorical\n\n\nGlucose (mg/dL)\n0.168\nContinuous\n\n\nGlycated Hemoglobin (%)\n0.152\nContinuous\n\n\nBody Mass Index (kg/m²)\n0.107\nContinuous\n\n\nBlood Pressure (mmHg)\n0.096\nContinuous\n\n\nWaist Circumference (cm)\n0.087\nContinuous\n\n\nHip Circumference (cm)\n0.083\nContinuous\n\n\nAge (years)\n0.068\nContinuous\n\n\nMedication Use\n0.064\nCategorical\n\n\nHypertension\n0.028\nCategorical\n\n\nWaist-to-Hip Ratio\n0.022\nContinuous\n\n\nLDL Cholesterol (mg/dL)\n0.019\nContinuous\n\n\nDiet Type\n0.016\nCategorical\n\n\nHDL Cholesterol (mg/dL)\n-0.009\nContinuous\n\n\nTriglycerides (mg/dL)\n-0.008\nContinuous\n\n\n\n Source: Prepared by the author.\n\n\n\n\n\n\n\n\n\n\nFrom the given correlations we can create bivariate graphs with the variable of interest and a covariate.\nFor continuous covariates, we will use the boxplot as visualization and for categorical variables, stacked bar graphs.\n\ndiabetes_dataset %&gt;% # Open the database\nggplot(aes(x = as.factor(FamilyHistory), fill = as.factor(Outcome))) + # Call the graphing function, filling in the outcome\ngeom_bar(position = \"fill\", color = \"white\") + # Proportion within each group\nscale_fill_manual(values= c(\"#C97064\", \"#68A357\"), labels = c(\"No Diabetes\", \"Diabetes\")) + # Choose colors\nlabs(title = \"Family History Distribution by Outcome\", # Add title\nx = \"Family History (0 = No, 1 = Yes)\", # Add labels\ny = \"Proportion\",\nfill = \"Outcome\")\n\n\n\n\n\n\n\n\n\ndiabetes_dataset %&gt;% # Open the database\nggplot(aes(x = as.factor(Outcome), y = Glucose, fill = as.factor(Outcome))) + # Call the function for filling graphs with the outcome\ngeom_boxplot(outlier.color = \"red\", outlier.shape = 16) + # Create the boxplot\nscale_fill_manual(values= c(\"#C97064\", \"#68A357\"), labels = c(\"No Diabetes\", \"Diabetes\")) + # Choose the colors\nlabs(title = \"Glucose Distribution by Outcome\", # Add title\nx = \"Outcome\", # Add captions\ny = \"Glucose (mg/dL)\",\nfill = \"Outcome\")\n\n\n\n\n\n\n\n\n\n\nFinal considerations\nThe step-by-step suggested here is both for creating initial reports and for the researcher himself to better understand the database worked on. It is essential to do each step carefully and understand the need for pre-processing variables, such as adjusting the character to factor, and adapting the scripts as needed.\nI hope this helps!"
  },
  {
    "objectID": "en/about.html",
    "href": "en/about.html",
    "title": "Good to See You Here!",
    "section": "",
    "text": "Good to See You Here!\nI’m Sofia Aguiar, a Statistics undergraduate at UFMG with a strong interest in public health and epidemiology. My research focuses on transforming data into tools that strengthen the healthcare system and support professionals in decision-making.\nI have experience with data visualization, statistical inference, and programming in R. Currently, I’m deepening my knowledge in Bayesian methods, machine learning, and Python to enhance my analyses and predictive modeling.\n\n📬 Contact\nFeel free to email me at sof.m.aguiar@gmail.com\n\n\n📌 Where to Find Me\n\nProgramming Projects: GitHub\n\nAcademic CV: Lattes\n\nAcademic Profile: OrcID\n\n\n\nMy Favorite Projects\n\nInterval Censored Survival Analysis - An application of interval censored survival analysis with a syntethic dataset\n\n\n\nR Tutorials for Researchers\n\nData Viz - A brief step by step on how to look at your dataset\n\n\nNotice: This site is under development. Changes may occur!"
  },
  {
    "objectID": "en/blog/survival-analysis.html",
    "href": "en/blog/survival-analysis.html",
    "title": "Análise de Sobrevivência com Censura Intervalar",
    "section": "",
    "text": "Warning! Translation still in proccess!\n\n\nAnálise de Sobrevivência com Censura Intervalar\n\nO que é Análise de Sobrevivência?\nA Análise de Sobrevivência é um conjunto de técnicas estatísticas utilizadas para modelar o tempo até a ocorrência de um evento de interesse. Esses eventos podem ser falhas em sistemas mecânicos, tempo até a recidiva de uma doença, ou até mesmo a duração de um contrato de serviço. O diferencial da Análise de Sobrevivência em relação a outras técnicas estatísticas é a presença de censura, que ocorre quando o evento de interesse não é completamente observado.\n\n\nCensura intervalar\nA censura intervalar ocorre quando o tempo exato do evento não é conhecido, mas sabe-se que ele aconteceu dentro de um intervalo de tempo. Isso é comum em estudos médicos, nos quais os pacientes são avaliados periodicamente e o evento pode ter ocorrido entre duas consultas. Modelos tradicionais de Análise de Sobrevivência, como Kaplan-Meier e modelos de riscos proporcionais de Cox, não são adequados para lidar com esse tipo de censura, sendo necessário utilizar abordagens específicas, como as curvas de Turnbull e a extensão do modelo de Cox para censura intervalar.\n\n\nPasso a passo\n\nPreparo do ambiente\nPara realizar a análise, utilizamos o R e carregamos os pacotes necessários para manipulação de dados e modelagem estatística.\n\n# Carregando os pacotes necessários\n\nlibrary(tidyverse)   # Pacote para manipulação e visualização de dados\nlibrary(survival)    # Pacote para análise de sobrevivência\nlibrary(icenReg)     # Pacote para análise de sobrevivência com censura intervalar\n\n\n\nObtenção dos dados sintéticos\nCriamos um conjunto de dados sintético com 600 indivíduos e algumas variáveis de interesse, como uma variável categórica, uma variável contínua e o tempo até a ocorrência do evento de interesse. A construção dos dados leva em consideração a influência das variáveis na probabilidade de o evento ocorrer.\n\nn &lt;- 600 # Número de indivíduos na base de dados\n\n# Número de observações por indivíduo, variando entre 2 e 5 observações\nobs_por_individuo &lt;- sample(2:5, n, replace = TRUE)\n\n# Expandindo os IDs para refletir múltiplas observações por indivíduo\ndados &lt;- data.frame(\n  ID = rep(1:n, times = obs_por_individuo)\n)\n\ndados &lt;- dados %&gt;%\n  mutate(\n    # Variável categórica exemplo (var_cat)\n    var_cat = rep(sample(c(0, 1), n, replace = TRUE), times = obs_por_individuo),\n    \n    # Variável contínua exemplo (var_cont), que possui dependência da variável categórica\n    var_cont = unlist(lapply(var_cat, function(s) {\n      if (s == 1) {\n        sample(5500:8000, 1)  # Valor para 'var_cat' igual a 1 \n      } else {\n        sample(1800:3500, 1)  # Valor para 'var_cat' igual a 0 \n      }\n    })),\n    \n    # Idade atual dos indivíduos, gerada aleatoriamente entre 0 e 10 anos\n    idade_atual = unlist(lapply(obs_por_individuo, function(x) runif(x, min = 0, max = 10))),\n    \n    # Risco do desfecho com base em 'var_cat' e 'var_cont'\n    risco_desfecho  = 0.2 + var_cat * (-0.4) + var_cont * 0.0001\n  )\n# Gerando a variável 'desfecho' a partir do risco, usando 0.5 como valor de corte\ndados = dados %&gt;% \n  mutate(desfecho = ifelse(risco_desfecho&gt;0.5,1,0)) %&gt;% \n  select(-risco_desfecho) # remove o risco\n\n\n\nTransformação em dados de sobrevivência\nOs dados brutos precisam ser transformados em um formato adequado para análise de sobrevivência com censura intervalar. Criamos as variáveis left (limite inferior do tempo do evento) e right (limite superior do tempo do evento), bem como a variável de censura (cens), que indica se o evento foi observado (1) ou censurado (0).\n\ndf_surv = dados %&gt;% \n  group_by(ID) %&gt;% \n  summarise(\n    left = ifelse(\n      any(desfecho == 1),\n      max(idade_atual[idade_atual &lt; min(idade_atual[desfecho == 1], na.rm = T)\n                      & desfecho == 0], na.rm = T),\n      max(idade_atual) # Caso não tenha ocorrência do evento, a maior idade é registrada\n    ),\n    right = ifelse(any(desfecho == 1),\n                   min(idade_atual[desfecho == 1], na.rm = T),\n                   NA), # Caso o evento não tenha ocorrido, substitui por NA\n    cens = ifelse(any(desfecho == 1), 1, 0),  # Indica se o evento foi observado (1) ou censurado (0)\n    var_cat = first(var_cat),   # Variáveis de covariáveis para análise\n    var_cont = first(var_cont)\n  ) %&gt;% \n  ungroup() %&gt;% \n  mutate(left = ifelse(left &lt; 0, 0, left))  # Garante que 'left' não seja negativo\n\n\n\nCurvas de Turnbull\nAs curvas de Turnbull são uma extensão do estimador de Kaplan-Meier para dados com censura intervalar. Implementamos uma função para calcular o vetor de tempos ótimos (tau), estimar a função de sobrevivência inicial e iterativamente atualizar as probabilidades de sobrevivência até a convergência do algoritmo.\nComparamos as curvas de sobrevivência entre dois grupos da variável categórica para verificar diferenças na distribuição do tempo até o evento.\n\n# Função para criar o vetor de tempos (tau) a partir dos intervalos censurados\n# O uso de digitos de arrendondamento é contribuição de Sofia Aguiar \n# a fim de evitar erros em bases meiores que 10 mil\ncria.tau &lt;- function(data, digits = 6) {\n  l &lt;- data$left\n  r &lt;- data$right\n  \n  # Arredonda os valores para evitar pequenas diferenças numéricas\n  l &lt;- round(l, digits = digits)\n  r &lt;- round(r, digits = digits)\n  \n  tau &lt;- sort(unique(c(l, r[is.finite(r)])))  # Combina os tempos de censura\n  return(tau)\n}\n\n# Função para inicializar a função de sobrevivência com base no vetor tau\nS.ini &lt;- function(tau){\n  m&lt;-length(tau)\n  ekm&lt;-survfit(Surv(tau[1:m-1],rep(1,m-1))~1)\n  So&lt;-c(1,ekm$surv)\n  p &lt;- -diff(So)\n  return(p)\n}\n\n# Função para construir a matriz A de intervalos de censura\ncria.A &lt;- function(data,tau){\n  tau12 &lt;- cbind(tau[-length(tau)],tau[-1]) # Cria os intervalos [tau[i], tau[i+1]]\n  interv &lt;- function(x,inf,sup) ifelse(x[1]&gt;=inf & x[2]&lt;=sup,1,0)\n  A &lt;- apply(tau12,1,interv,inf=data$left,sup=data$right)\n  id.lin.zero &lt;- which(apply(A==0, 1, all)) # Matriz de censura\n  if(length(id.lin.zero)&gt;0) A &lt;- A[-id.lin.zero, ] # Filtra intervalos não observados\n  return(A)\n}\n\n# Função de Turnbull, que realiza a estimação iterativa da função de sobrevivência\nTurnbull &lt;- function(p, A, data, eps=1e-3,\n                     iter.max=200, verbose=FALSE){\n  n&lt;-nrow(A)\n  m&lt;-ncol(A)\n  Q&lt;-matrix(1,m)\n  iter &lt;- 0\n  repeat {\n    iter &lt;- iter + 1\n    diff&lt;- (Q-p)\n    maxdiff&lt;-max(abs(as.vector(diff))) # Diferença máxima entre iterações\n    if (verbose)\n      print(maxdiff)\n    if (maxdiff&lt;eps | iter&gt;=iter.max)\n      break\n    Q&lt;-p\n    C&lt;-A%*%p\n    p&lt;-p*((t(A)%*%(1/C))/n) # Atualiza as estimativas de probabilidade\n  }\n    cat(\"Iterations = \", iter,\"\\n\")\n    cat(\"Max difference = \", maxdiff,\"\\n\")\n    cat(\"Convergence criteria: Max difference &lt; 1e-3\",\"\\n\")\n  dimnames(p)&lt;-list(NULL,c(\"P Estimate\"))\n  surv&lt;-round(c(1,1-cumsum(p)),digits=5)\n  right &lt;- data$right\n   if(any(!(is.finite(right)))){\n    t &lt;- max(right[is.finite(right)])\n    return(list(time=tau[tau&lt;t],surv=surv[tau&lt;t]))\n  }\n  else\n    return(list(time=tau,surv=surv)) # Retorna a função de sobrevivência\n}\n\n\n# Estimação da função de sobrevivência para 'var_cat' igual a 0 e 1 \ndat1 = df_surv[df_surv$var_cat == 0,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb1 = Turnbull(p, A, dat1)\n\nIterations =  47 \nMax difference =  0.0009869879 \nConvergence criteria: Max difference &lt; 1e-3 \n\ndat1 = df_surv[df_surv$var_cat == 1,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb2 = Turnbull(p, A, dat1)\n\nIterations =  83 \nMax difference =  0.0009990949 \nConvergence criteria: Max difference &lt; 1e-3 \n\n# Visualização das funções de sobrevivência para os dois grupos\npar(mfrow = c(1, 1))\nplot(tb1$time, tb1$surv, col = \"red\", type = \"s\", ylim = c(0, 1), xlim = c(0, 10),\n     xlab = \"Tempo em anos\", ylab = \"S(t)\")\nlines(tb2$time, tb2$surv, col = \"blue\", type = \"s\")\nlegend(7.5, 0.9, lty = 1, col = c(\"red\", \"blue\"), c(\"Categoria 0\", \"Categoria 1\"),\n       bty = \"n\", cex = 0.9)\n\n\n\n\n\n\n\n\n\n\nExtensão do modelo de cox para censura intervalar\nO modelo de riscos proporcionais de Cox é amplamente utilizado em análise de sobrevivência, mas precisa ser adaptado para lidar com censura intervalar. Utilizamos o pacote icenReg para estimar os coeficientes do modelo de Cox estendido para censura intervalar. Ajustamos modelos univariados e multivariados para identificar quais variáveis estão associadas ao tempo até o evento.\n\nm = max(summary(df_surv$right))  # Máximo dos valores de censura\nli = df_surv$left \nui = ifelse(is.na(df_surv$right), m + 1000, df_surv$right)  # Ajuste para censura direita\n\n# Ajuste do modelo de Cox para a variável categórica\nfit1 = ic_sp(cbind(li, ui) ~ var_cat, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit1)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n        Estimate Exp(Est) Std.Error z-value         p\nvar_cat   0.3317    1.393   0.09634   3.443 0.0005751\n\nfinal llk =  -905.6817 \nIterations =  52 \nBootstrap Samples =  100 \n\n# Ajuste do modelo de Cox para a variável contínua\nfit2 = ic_sp(cbind(li, ui) ~ var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit2)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cont, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n          Estimate Exp(Est) Std.Error z-value         p\nvar_cont 0.0001384        1 1.912e-05   7.241 4.468e-13\n\nfinal llk =  -893.677 \nIterations =  50 \nBootstrap Samples =  100 \n\n# Seleção das variáveis com p-valor &lt; 0,25 para a análise multivariada\nfit3 = ic_sp(cbind(li, ui) ~ var_cat + var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit3)\n\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat + var_cont, data = df_surv, \n    model = \"ph\", bs_samples = 100)\n\n           Estimate Exp(Est) Std.Error z-value         p\nvar_cat  -3.2240000  0.03981 0.4413000  -7.306 2.758e-13\nvar_cont  0.0008674  1.00100 0.0001024   8.474 0.000e+00\n\nfinal llk =  -855.8689 \nIterations =  31 \nBootstrap Samples =  100 \n\n\n\n\nSeleção de variáveis\nPara selecionar as variáveis mais relevantes, utilizamos um procedimento iterativo baseado na log-verossimilhança. Variáveis com baixa contribuição para o modelo podem ser removidas para simplificar a interpretação dos resultados e reduzir o sobreajuste.\n\nstep_icph &lt;- function(model, data) {\n  vars &lt;- attr(terms(model$formula), \"term.labels\")  # Variáveis do modelo\n  current_model &lt;- model\n  best_llk &lt;- current_model$llk  # Log-verossimilhança inicial\n  \n  # Processo iterativo de remoção de variáveis com base na log-verossimilhança\n  for (var in vars) {\n    formula_new &lt;- as.formula(paste(\"cbind(li, ui) ~\", \n                                    paste(setdiff(vars, var), collapse = \" + \")))\n    model_new &lt;- ic_sp(formula_new, model = \"ph\", bs_samples = 100, data = data)\n    new_llk &lt;- model_new$llk  # Log-verossimilhança do novo modelo\n    \n    # Diagnóstico e atualização do modelo\n    if (new_llk &gt; best_llk) {\n      best_llk &lt;- new_llk\n      current_model &lt;- model_new\n      vars &lt;- setdiff(vars, var)\n    }\n  }\n  \n  return(current_model)  # Retorna o modelo final\n}\n\n\n\n\nConclusão\nA análise de sobrevivência com censura intervalar permite estudar fenômenos nos quais o tempo exato do evento é desconhecido, mas delimitado dentro de um intervalo. O uso das curvas de Turnbull e da extensão do modelo de Cox para censura intervalar são ferramentas fundamentais para extrair informações valiosas desses dados. A seleção cuidadosa de variáveis melhora a precisão dos modelos e ajuda a compreender os fatores que influenciam o tempo até o evento de interesse.\n\n\nReferências\nANDERSON-BERGMAN, C. icenReg: Regression models for interval censored data in R. Versão 2.0. Disponível em: https://cran.r-project.org/package=icenReg. Acesso em: 19 dez. 2024\nCOLOSIMO, E. A.; GIOLO, S. R. Análise de sobrevivência aplicada. Blücher, 2024.\nSUN, Y. Survival data analysis with interval-censored data. Statistics in Medicine, v. 25, p. 3563-3578, 2006.\nTHERNEAU, T. M. survival: Survival Analysis, Including Penalised Likelihood (versão 3.4-0). 2023. Disponível em: https://cran.r-project.org/web/packages/survival/index.html. Acesso em: 16 dez. 2024.\nTURNBULL, B. W. The empirical distribution function with arbitrarily grouped, censored and truncated data. Journal of the Royal Statistical Society, v. 38, p. 290-295, 1976."
  },
  {
    "objectID": "ptbr/blog/data-viz.html",
    "href": "ptbr/blog/data-viz.html",
    "title": "Como vizualizar seu banco de dados - fazendo belos gráficos e tabelas",
    "section": "",
    "text": "Como vizualizar seu banco de dados - fazendo belos gráficos e tabelas\nMuitas vezes uma análise descritiva e explotaória bem feita pode mudar os rumos da sua pesquisa. Esse é o momento ideal de pensar no seu objetivo de pesquisa, qual o escopo do seu trabalho e quais são as principais informações pelas quais se deve atentar.\nNesse tutorial usaremos o banco de dados disponível através do Kaggle aqui. Ele descreve mais de 9 mil registros médicos de pacientes associados ao risco de diabetes.\n\nAntes de tudo, prepare o ambiente\nEm programação, ter o código organizado é fundamental. Tanto para que você mesmo possa retornar às análises que fez e entender o que foi feito tanto para colaboração com outros pesquisadores.\nComeçaremos com as configurações do nosso ambiente, carregando os pacotes necessários e outras configurações.\n\n# Pacotes utilizados\n# Essa estrutura carrega e instala os pacotes caso eles não estejam instalados ainda\nif(!require(tidyverse)) install.packages(\"tidyverse\")\nif(!require(kableExtra)) install.packages(\"kableExtra\")\nif(!require(ggcorrplot)) install.packages(\"ggcorrplot\")\nif(!require(corrr)) install.packages(\"corrr\")\nif(!require(rstatix)) install.packages(\"rstatix\")\n\n# Para possíveis variáveis com valores muito pequenos ou muito grandes, essa opção\n# evita a notaçào científica\noptions(scipen = 9999)\n\n\n\nCarregue seu banco\nPara bancos de dados em plataformas como o Kagle, há n formas de carregar o banco além do tradicional baixar e carregar o arquivo. No meu caso eu fiz download do banco e subi ele para o gitHub do site já que vou utilizar esse mesmo dataset várias vezes.\n\n# Navega pelas pastas e carrega o banco de dados em .csv\ndiabetes_dataset = read.csv(\"../../assets/datasets/diabetes_dataset.csv\")\n\nAntes de fazer qualquer análise temos que verificar o banco. Faça algumas perguntas:\n\nTodas as colunas foram lidas de forma correta?\nAs casas decimais foram configuradas corretamente?\nQuais são os tipos de cada coluna?\nOs caracteres estão bem configurados?\n\nPara responder isso dois comando simples e um pouco de conhecimento do que cada variável significa basta.\n\n# Mostra cada coluna, o tipo e as primeiras observações\nglimpse(diabetes_dataset)\n\nRows: 9,538\nColumns: 17\n$ Age                &lt;int&gt; 69, 32, 89, 78, 38, 41, 20, 39, 70, 19, 47, 55, 19,…\n$ Pregnancies        &lt;int&gt; 5, 1, 13, 13, 8, 10, 16, 4, 3, 1, 8, 0, 15, 12, 6, …\n$ BMI                &lt;dbl&gt; 28.39, 26.49, 25.34, 29.91, 24.56, 17.47, 15.76, 28…\n$ Glucose            &lt;dbl&gt; 130.1, 116.5, 101.0, 146.0, 103.2, 67.0, 61.6, 105.…\n$ BloodPressure      &lt;dbl&gt; 77, 72, 82, 104, 74, 71, 60, 94, 90, 62, 93, 87, 60…\n$ HbA1c              &lt;dbl&gt; 5.4, 4.5, 4.9, 5.7, 4.7, 4.2, 4.0, 4.5, 4.0, 4.0, 4…\n$ LDL                &lt;dbl&gt; 130.4, 87.4, 112.5, 50.7, 102.5, 105.3, 62.4, 91.0,…\n$ HDL                &lt;dbl&gt; 44.0, 54.2, 56.8, 39.1, 29.1, 58.8, 43.4, 50.1, 51.…\n$ Triglycerides      &lt;dbl&gt; 50.0, 129.9, 177.6, 117.0, 145.9, 140.7, 64.6, 195.…\n$ WaistCircumference &lt;dbl&gt; 90.5, 113.3, 84.7, 108.9, 84.1, 81.8, 66.5, 123.2, …\n$ HipCircumference   &lt;dbl&gt; 107.9, 81.4, 107.2, 110.0, 92.8, 93.2, 102.7, 121.4…\n$ WHR                &lt;dbl&gt; 0.84, 1.39, 0.79, 0.99, 0.91, 0.88, 0.65, 1.01, 0.7…\n$ FamilyHistory      &lt;int&gt; 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, …\n$ DietType           &lt;int&gt; 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 1, 1, …\n$ Hypertension       &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ MedicationUse      &lt;int&gt; 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, …\n$ Outcome            &lt;int&gt; 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, …\n\n\n\n# Mostra as 6 primeiras linhas do banco de dados\nhead(diabetes_dataset)\n\n  Age Pregnancies   BMI Glucose BloodPressure HbA1c   LDL  HDL Triglycerides\n1  69           5 28.39   130.1            77   5.4 130.4 44.0          50.0\n2  32           1 26.49   116.5            72   4.5  87.4 54.2         129.9\n3  89          13 25.34   101.0            82   4.9 112.5 56.8         177.6\n4  78          13 29.91   146.0           104   5.7  50.7 39.1         117.0\n5  38           8 24.56   103.2            74   4.7 102.5 29.1         145.9\n6  41          10 17.47    67.0            71   4.2 105.3 58.8         140.7\n  WaistCircumference HipCircumference  WHR FamilyHistory DietType Hypertension\n1               90.5            107.9 0.84             0        0            0\n2              113.3             81.4 1.39             0        0            0\n3               84.7            107.2 0.79             0        0            0\n4              108.9            110.0 0.99             0        0            0\n5               84.1             92.8 0.91             0        1            0\n6               81.8             93.2 0.88             1        0            0\n  MedicationUse Outcome\n1             1       0\n2             0       0\n3             1       0\n4             1       1\n5             0       0\n6             0       1\n\n\nTudo certo! Podemos continuar.\n\n\nLeitura do dicionário\nO último passo antes de uma boa análise descritiva e exploratória é ler o dicionário de variáveis. Isso é fundamental para entender siglas que podem estar em outra língua, verificar a unidade de medida de cada variável e já identificar sobre qual o tipo de cada coluna.\n\nIdade (Age): Idade do indivíduo (18-90 anos).\nGravidezes (Pregnancies): Número de vezes que a paciente esteve grávida. -IMC (Índice de Massa Corporal - BMI): Medida de gordura corporal baseada na altura e peso (kg/m²).\nGlicose (Glucose): Concentração de glicose no sangue (mg/dL), um indicador-chave de diabetes.\nPressão Arterial (BloodPressure): Pressão arterial sistólica (mmHg), níveis elevados podem indicar hipertensão.\nHbA1c: Nível de hemoglobina glicada (%), representa a média de açúcar no sangue ao longo de meses.\nLDL (Lipoproteína de Baixa Densidade - Low-Density Lipoprotein): Nível de colesterol “ruim” (mg/dL).\nHDL (Lipoproteína de Alta Densidade - High-Density Lipoprotein): Nível de colesterol “bom” (mg/dL).\nTriglicerídeos (Triglycerides): Níveis de gordura no sangue (mg/dL), valores altos aumentam o risco de diabetes.\nCircunferência da Cintura (WaistCircumference): Medida da cintura (cm), indicador de obesidade central.\nCircunferência do Quadril (HipCircumference): Medida do quadril (cm), usada para calcular a relação cintura-quadril.\nRelação Cintura-Quadril (WHR - Waist-to-Hip Ratio): Circunferência da cintura dividida pela circunferência do quadril.\nHistórico Familiar (FamilyHistory): Indica se o indivíduo tem histórico familiar de diabetes (1 = Sim, 0 = Não).\nTipo de Dieta (DietType): Hábitos alimentares (0 = Desequilibrado, 1 = Equilibrado, 2 = Vegano/Vegetariano).\nHipertensão (Hypertension): Presença de pressão alta (1 = Sim, 0 = Não).\nUso de Medicamentos (MedicationUse): Indica se o indivíduo faz uso de medicação (1 = Sim, 0 = Não).\nResultado (Outcome): Diagnóstico de diabetes (1 = Diabetes, 0 = Sem Diabetes).\n\n\n\nAnálise univariada\nFinalmente chegamos na etapa de criar gráficos e tabelas. Um importante conhecimento é saber distinguir variáveis contínuas (números e medidas) de variáveis categóricas (classificação de algum tipo, como raça e sexo).\nPara variáveis conitínuas, as medidas resumo em uma única tabela são uma excelente forma de adicionar informação em um relatório. Para fins de você, pesquisador, entender seu banco de dados, criar histogramas é uma ótima forma de visualizar o que está acontecendo com cada coluna, perceber outliers e assimetria, mesmo que não os inclua no relatório.\nAssim, para executar o histograma recomendo utilizar o pacote ggplot2, que traz um belo gráfico com relativamente pouco esforço.\n\ndiabetes_dataset %&gt;%  # Abre o banco de dados\n  select(WaistCircumference) %&gt;% # Seleciona a variável de interesse\n  ggplot(aes(x = WaistCircumference)) + # Chama a função de criar gráficos colocando nossa var no eixo x\n  geom_histogram(fill = \"#F2C354\", color = \"white\") + # Cria o histograma com as cores desejadas\n  labs(title = \"Histograma para Circunferência de Cintura em cm\", # Adiciona título \n       x = \"Circunferência de Cintuta (cm)\", # E substitui o texto padrão dos eixos\n       y = \"Frequência\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nE agora para a nossa tabela precisaremos de um pouco mais de código.\n\n# Definimos os rótulos em português para cada variável categórica\nrotulos_categoricas &lt;- c(\n  FamilyHistory = \"Histórico Familiar\",  # Indica se o indivíduo tem histórico familiar de diabetes (1 = Sim, 0 = Não)\n  DietType = \"Tipo de Dieta\",  # Hábitos alimentares (0 = Desequilibrado, 1 = Equilibrado, 2 = Vegano/Vegetariano)\n  Hypertension = \"Hipertensão\",  # Presença de pressão alta (1 = Sim, 0 = Não)\n  MedicationUse = \"Uso de Medicamentos\",  # Indica se o indivíduo faz uso de medicação (1 = Sim, 0 = Não)\n  Outcome = \"Resultado\"  # Diagnóstico de diabetes (1 = Diabetes, 0 = Sem Diabetes)\n)\n\n# Selecionamos apenas as variáveis categóricas com base nos rótulos definidos\nvariaveis_categoricas &lt;- names(rotulos_categoricas)\n\n# Calcular a frequência e a proporção para cada categoria das variáveis categóricas\nresumo_categoricas &lt;- diabetes_dataset %&gt;%  # Acessa o dataset\n  select(all_of(variaveis_categoricas)) %&gt;%  # Seleciona as colunas categóricas\n  pivot_longer(cols = everything(), names_to = \"Variável\", values_to = \"Categoria\") %&gt;%  # Converte o formato wide para long\n  group_by(Variável, Categoria) %&gt;%  # Agrupa pelos valores únicos das variáveis categóricas\n  summarise(Frequência = n(), .groups = \"drop\") %&gt;%  # Conta quantas vezes cada categoria aparece\n  mutate(Proporção = Frequência / sum(Frequência) * 100) %&gt;%  # Calcula a porcentagem relativa de cada categoria\n  mutate(Variável = recode(Variável, !!!rotulos_categoricas))  # Substitui os nomes das variáveis pelos rótulos em português\n\n# Criamos a tabela formatada\nresumo_categoricas %&gt;%  # Chama o resumo criado\n  kable(\"html\", \n        caption = \"Distribuição das variáveis categóricas\",  # Utiliza o kable da biblioteca kableExtra\n        align = \"c\",  # Alinha o texto ao centro\n        col.names = c(\"Variável\", \"Categoria\", \"Frequência\", \"Proporção (%)\")) %&gt;%  # Define os nomes das colunas\n  kable_styling(full_width = FALSE, \n                bootstrap_options = c(\"striped\", \"hover\")) %&gt;%  # Aplica configurações de estilo\n  footnote(general = \"Fonte: Elaborado pelo autor.\",  # Adiciona a fonte da tabela\n           general_title = \"\") %&gt;%\n  add_header_above(c(\" \" = 1, \"Estatísticas Descritivas\" = 3))  # Adiciona um cabeçalho para as colunas de estatísticas\n\n\nDistribuição das variáveis categóricas\n\n\n\n\n\n\n\n\n\n\nEstatísticas Descritivas\n\n\n\nVariável\nCategoria\nFrequência\nProporção (%)\n\n\n\n\nTipo de Dieta\n0\n5794\n12.1492975\n\n\nTipo de Dieta\n1\n2851\n5.9781925\n\n\nTipo de Dieta\n2\n893\n1.8725100\n\n\nHistórico Familiar\n0\n6653\n13.9505137\n\n\nHistórico Familiar\n1\n2885\n6.0494863\n\n\nHipertensão\n0\n9528\n19.9790312\n\n\nHipertensão\n1\n10\n0.0209688\n\n\nUso de Medicamentos\n0\n5675\n11.8997693\n\n\nUso de Medicamentos\n1\n3863\n8.1002307\n\n\nResultado\n0\n6256\n13.1180541\n\n\nResultado\n1\n3282\n6.8819459\n\n\n\n Fonte: Elaborado pelo autor.\n\n\n\n\n\n\n\n\n\n\n\nPara outras formatações basta pesquisar um pouco na documentação do pacote kableExtra e entender o que precisa ser alterado.\nPara variáveis categóricas, o processo é bem similar. Iremos criar um gráfico de barras (nunca de pizza!!) e uma tabela com as medidas resumo.\n\ndiabetes_dataset %&gt;%  # Abre o banco de dados\n  select(FamilyHistory) %&gt;% # Seleciona a variável de interesse\n  ggplot(aes(x = as.factor(FamilyHistory))) + # Chama a função de criar gráficos colocando nossa var no eixo x como fator (ou seja var categorica)\n  geom_bar(fill = \"#C97064\", color = \"white\") + # Cria o ghráfico de barras com as cores desejadas\n  labs(title = \"Distribuição para Histórico Familiar de Daibetes\", # Adiciona título \n       x = \"Possui histórico familiar? (0 = não, 1 = sim)\", # E substitui o texto padrão dos eixos\n       y = \"Frequência\")\n\n\n\n\n\n\n\n\nPode ser interessante também criar um gráfico para as proporções do grupo no eixo y, a fim de facilitar a vizualização. Basta alterar algumas linhas de código como se vê abaixo.\n\ndiabetes_dataset %&gt;%  # Abre o banco de dados\n  count(FamilyHistory) %&gt;% # Conta as ocorrências de cada categoria\n  mutate(Proporção = n / sum(n)) %&gt;% # Calcula a proporção\n  ggplot(aes(x = as.factor(FamilyHistory), y = Proporção)) + # Define os eixos\n  geom_col(fill = \"#68A357\", color = \"white\") + # Cria o gráfico de barras\n  labs(title = \"Distribuição do Histórico Familiar de Diabetes\", # Adiciona título\n       x = \"Possui histórico familiar? (0 = não, 1 = sim)\", # E substitui o texto padrão dos eixos\n       y = \"Proporção\") \n\n\n\n\n\n\n\n\nPor fim, agora vamos fazer as tabelas para as variáveis categóricas.\n\n# Definimos os rótulos em português para cada variável categórica\nrotulos_categoricas &lt;- c(\n  FamilyHistory = \"Histórico Familiar\",  # Indica se o indivíduo tem histórico familiar de diabetes (1 = Sim, 0 = Não)\n  DietType = \"Tipo de Dieta\",  # Hábitos alimentares (0 = Desequilibrado, 1 = Equilibrado, 2 = Vegano/Vegetariano)\n  Hypertension = \"Hipertensão\",  # Presença de pressão alta (1 = Sim, 0 = Não)\n  MedicationUse = \"Uso de Medicamentos\",  # Indica se o indivíduo faz uso de medicação (1 = Sim, 0 = Não)\n  Outcome = \"Resultado\"  # Diagnóstico de diabetes (1 = Diabetes, 0 = Sem Diabetes)\n)\n\n# Selecionamos apenas as variáveis categóricas com base nos rótulos definidos\nvariaveis_categoricas &lt;- names(rotulos_categoricas)\n\n# Calcular a frequência e a proporção para cada categoria das variáveis categóricas\nresumo_categoricas &lt;- diabetes_dataset %&gt;%  # Acessa o dataset\n  select(all_of(variaveis_categoricas)) %&gt;%  # Seleciona as colunas categóricas\n  pivot_longer(cols = everything(), names_to = \"Variável\", values_to = \"Categoria\") %&gt;%  # Converte o formato wide para long\n  group_by(Variável, Categoria) %&gt;%  # Agrupa pelos valores únicos das variáveis categóricas\n  summarise(Frequência = n(), .groups = \"drop\") %&gt;%  # Conta quantas vezes cada categoria aparece\n  mutate(Proporção = Frequência / sum(Frequência) * 100) %&gt;%  # Calcula a porcentagem relativa de cada categoria\n  mutate(Variável = recode(Variável, !!!rotulos_categoricas))  # Substitui os nomes das variáveis pelos rótulos em português\n\n# Ajustamos para remover a repetição do nome da variável\nresumo_categoricas &lt;- resumo_categoricas %&gt;%\n  group_by(Variável) %&gt;%\n  mutate(Variável = ifelse(row_number() == 1, Variável, \"\")) %&gt;%  # Mantém o nome apenas na primeira linha de cada grupo\n  ungroup()\n\n# Criamos a tabela formatada\nresumo_categoricas %&gt;%  # Chama o resumo criado\n  kable(\"html\", \n        caption = \"Distribuição das variáveis categóricas\",  # Utiliza o kable da biblioteca kableExtra\n        align = \"c\",  # Alinha o texto ao centro\n        col.names = c(\"Variável\", \"Categoria\", \"Frequência\", \"Proporção (%)\")) %&gt;%  # Define os nomes das colunas\n  kable_styling(full_width = FALSE, \n                bootstrap_options = c(\"striped\", \"hover\")) %&gt;%  # Aplica configurações de estilo\n  footnote(general = \"Fonte: Elaborado pelo autor.\",  # Adiciona a fonte da tabela\n           general_title = \"\") %&gt;%\n  add_header_above(c(\" \" = 1, \"Estatísticas Descritivas\" = 3))  # Adiciona um cabeçalho para as colunas de estatísticas\n\n\nDistribuição das variáveis categóricas\n\n\n\n\n\n\n\n\n\n\nEstatísticas Descritivas\n\n\n\nVariável\nCategoria\nFrequência\nProporção (%)\n\n\n\n\nTipo de Dieta\n0\n5794\n12.1492975\n\n\n\n1\n2851\n5.9781925\n\n\n\n2\n893\n1.8725100\n\n\nHistórico Familiar\n0\n6653\n13.9505137\n\n\n\n1\n2885\n6.0494863\n\n\nHipertensão\n0\n9528\n19.9790312\n\n\n\n1\n10\n0.0209688\n\n\nUso de Medicamentos\n0\n5675\n11.8997693\n\n\n\n1\n3863\n8.1002307\n\n\nResultado\n0\n6256\n13.1180541\n\n\n\n1\n3282\n6.8819459\n\n\n\n Fonte: Elaborado pelo autor.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnálise bivariada\nA análise univariada tem como objetivo entender a distribuição da variável em si. Já na análise bivariada (e multivariada), queremos entender qual a relação das variáveis entre si. Note que não estou buscando a causalidade nem no valor preditivo de cada variável, isso será uma etapa posterior a depender do seu objetivo de pesquisa.\nPodemos começar com um correlograma, que traz um mapa das correlações de todas as variáveis contínuas entre si. É muito útil para identificar se há alguma colinearidade entre variáveis, que deve ser confirmada depois através dos testes apropriados.\n\n# Selecionamos apenas as variáveis contínuas\nvariaveis_continuas &lt;- c(\"Age\", \"BMI\", \"Glucose\", \"BloodPressure\", \"HbA1c\",\n                         \"LDL\", \"HDL\", \"Triglycerides\", \"WaistCircumference\",\n                         \"HipCircumference\", \"WHR\")\n\n# Criamos a matriz de correlação\nmatriz_correlacao &lt;- diabetes_dataset %&gt;% \n  select(all_of(variaveis_continuas)) %&gt;%  # Seleciona apenas as variáveis contínuas\n  cor(use = \"pairwise.complete.obs\")  # Calcula a correlação excluindo valores NA\n\n# Criamos o correlograma\nggcorrplot(matriz_correlacao, \n           method = \"circle\",  # Define o estilo do gráfico (círculos)\n           type = \"lower\",  # Mostra apenas a metade inferior da matriz\n           lab = TRUE,  # Exibe os valores das correlações\n           lab_size = 3,  # Tamanho da fonte dos rótulos\n           colors = c(\"#6D9EC1\", \"white\", \"#E46726\"),  # Define a paleta de cores\n           title = \"Correlograma das Variáveis Contínuas\",  # Adiciona um título\n           ggtheme = theme_minimal())  # Aplica um tema minimalista\n\n\n\n\n\n\n\n\nOutra forma de correlação muito importante, principalmente para estudos de predição, é a correlação de cada variável com o desfecho.\n\n# Definimos variáveis contínuas e categóricas\nvariaveis_continuas &lt;- c(\"Age\", \"BMI\", \"Glucose\", \"BloodPressure\", \"HbA1c\",\n                         \"LDL\", \"HDL\", \"Triglycerides\", \"WaistCircumference\",\n                         \"HipCircumference\", \"WHR\")\n\nvariaveis_categoricas &lt;- c(\"FamilyHistory\", \"DietType\", \"Hypertension\", \n                           \"MedicationUse\")\n\n# --- Correlação para variáveis contínuas com Outcome ---\ncorrelacoes_continuas &lt;- diabetes_dataset %&gt;% \n  select(all_of(variaveis_continuas), Outcome) %&gt;% \n  cor(use = \"pairwise.complete.obs\") %&gt;% \n  as.data.frame() %&gt;%\n  select(Outcome) %&gt;%\n  rownames_to_column(var = \"Variável\") %&gt;%\n  rename(`Correlação` = Outcome) %&gt;%  # Renomeia para manter consistência\n  mutate(Tipo = \"Contínua\")\n\n# --- Correlação para variáveis categóricas com Outcome ---\ncalcular_cramer &lt;- function(var) {\n  tab &lt;- table(diabetes_dataset[[var]], diabetes_dataset$Outcome)\n  cramer &lt;- rstatix::cramer_v(tab) %&gt;% as.numeric()  # Converte para número\n  return(data.frame(Variável = var, `Correlação` = cramer, Tipo = \"Categórica\"))\n}\n\ncorrelacoes_categoricas &lt;- bind_rows(lapply(variaveis_categoricas, calcular_cramer))\n\nWarning in stats::chisq.test(x, y, correct = correct, ...): Aproximação do\nqui-quadrado pode estar incorreta\n\n# --- Juntamos todas as correlações ---\ncorrelacoes_totais &lt;- bind_rows(correlacoes_continuas, correlacoes_categoricas) %&gt;%\n  arrange(desc(abs(Correlação)))  # Ordena pela força da correlação\n\n# Defininmos os rótulos em português para todas as variáveis\nrotulos &lt;- c(\n  Age = \"Idade (anos)\",\n  BMI = \"Índice de Massa Corporal (kg/m²)\",\n  Glucose = \"Glicose (mg/dL)\",\n  BloodPressure = \"Pressão Arterial (mmHg)\",\n  HbA1c = \"Hemoglobina Glicada (%)\",\n  LDL = \"Colesterol LDL (mg/dL)\",\n  HDL = \"Colesterol HDL (mg/dL)\",\n  Triglycerides = \"Triglicerídeos (mg/dL)\",\n  WaistCircumference = \"Circunferência da Cintura (cm)\",\n  HipCircumference = \"Circunferência do Quadril (cm)\",\n  WHR = \"Relação Cintura-Quadril\",\n  FamilyHistory = \"Histórico Familiar\",\n  DietType = \"Tipo de Dieta\",\n  Hypertension = \"Hipertensão\",\n  MedicationUse = \"Uso de Medicamentos\"\n)\n\n# Removemos a correlação de Outcome consigo mesmo\ncorrelacoes_totais &lt;- correlacoes_totais %&gt;% \n  filter(Variável != \"Outcome\") %&gt;% \n  mutate(Variável = recode(Variável, !!!rotulos))  # Aplicar rótulos\n\n# Exibimos a tabela formatada\ncorrelacoes_totais %&gt;%\n  mutate(Correlação = round(Correlação, 3)) %&gt;%  # Arredonda valores\n  kable(\"html\", \n        caption = \"Correlação de Todas as Variáveis com o Desfecho\", \n        align = \"c\", \n        col.names = c(\"Variável\", \"Correlação\", \"Tipo\")) %&gt;%  # Define nomes das colunas\n  kable_styling(full_width = FALSE, \n                bootstrap_options = c(\"striped\", \"hover\")) %&gt;%  # Estilização\n  footnote(general = \"Fonte: Elaborado pelo autor.\", \n           general_title = \"\") %&gt;%\n  add_header_above(c(\" \" = 1, \"Correlação com o Desfecho\" = 2))  # Cabeçalho superior\n\n\nCorrelação de Todas as Variáveis com o Desfecho\n\n\n\n\n\n\n\n\n\nCorrelação com o Desfecho\n\n\n\nVariável\nCorrelação\nTipo\n\n\n\n\nHistórico Familiar\n0.909\nCategórica\n\n\nGlicose (mg/dL)\n0.168\nContínua\n\n\nHemoglobina Glicada (%)\n0.152\nContínua\n\n\nÍndice de Massa Corporal (kg/m²)\n0.107\nContínua\n\n\nPressão Arterial (mmHg)\n0.096\nContínua\n\n\nCircunferência da Cintura (cm)\n0.087\nContínua\n\n\nCircunferência do Quadril (cm)\n0.083\nContínua\n\n\nIdade (anos)\n0.068\nContínua\n\n\nUso de Medicamentos\n0.064\nCategórica\n\n\nHipertensão\n0.028\nCategórica\n\n\nRelação Cintura-Quadril\n0.022\nContínua\n\n\nColesterol LDL (mg/dL)\n0.019\nContínua\n\n\nTipo de Dieta\n0.016\nCategórica\n\n\nColesterol HDL (mg/dL)\n-0.009\nContínua\n\n\nTriglicerídeos (mg/dL)\n-0.008\nContínua\n\n\n\n Fonte: Elaborado pelo autor.\n\n\n\n\n\n\n\n\n\n\nA partir das correlações dadas podemos criar gráficos bivariados com a variável de interesse e uma covariável.\nPara covariável contínua, utilizaremos o boxplot como visualização e para variáveis categóricas gráficos de barras empilhadas.\n\ndiabetes_dataset %&gt;% # Abre o banco de dados\n  ggplot(aes(x = as.factor(FamilyHistory), fill = as.factor(Outcome))) + # Chama a função de gráficos preenchendo com o desfecho\n  geom_bar(position = \"fill\", color = \"white\") +  # Proporção dentro de cada grupo\n  scale_fill_manual(values = c(\"#C97064\", \"#68A357\"), labels = c(\"Sem Diabetes\", \"Diabetes\")) + # Escolhe as cores\n  labs(title = \"Distribuição do Histórico Familiar por Desfecho\", # Adiciona título\n       x = \"Histórico Familiar (0 = Não, 1 = Sim)\",  # Adiciona legendas\n       y = \"Proporção\",\n       fill = \"Desfecho\")\n\n\n\n\n\n\n\n\n\ndiabetes_dataset %&gt;% # Abre o banco de dados\n  ggplot(aes(x = as.factor(Outcome), y = Glucose, fill = as.factor(Outcome))) + # Chama a função de gráficos com preenchimento com o desfecho\n  geom_boxplot(outlier.color = \"red\", outlier.shape = 16) + # Cria o boxplot\n  scale_fill_manual(values = c(\"#C97064\", \"#68A357\"), labels = c(\"Sem Diabetes\", \"Diabetes\")) + # Escolhe as cores\n  labs(title = \"Distribuição da Glicose por Desfecho\", # Adiciona título\n       x = \"Desfecho\", # Adiciona legendas\n       y = \"Glicose (mg/dL)\",\n       fill = \"Desfecho\")\n\n\n\n\n\n\n\n\n\n\nConsiderações finais\nO passo a passo sugerido aqui é tanto para criação de relatórios iniciais tanto quanto para o próprio pesquisador entender melhor a base de dados trabalhada. É fundamental fazer cada etapa com cuidado e perceber a necessidade de pré-processamento das variáveis, como ajuste de character para factor, e adaptar os scripts conforme a necessidade.\nEspero ter ajudado!"
  }
]