{
  "hash": "0d7ced25d15875324babbc1bdf581719",
  "result": {
    "engine": "knitr",
    "markdown": "# **Análise de Sobrevivência com Censura Intervalar**\n\n\n### O que é Análise de Sobrevivência?\n\nA Análise de Sobrevivência é um conjunto de técnicas estatísticas utilizadas para modelar o tempo até a ocorrência de um evento de interesse. Esses eventos podem ser falhas em sistemas mecânicos, tempo até a recidiva de uma doença, ou até mesmo a duração de um contrato de serviço. O diferencial da Análise de Sobrevivência em relação a outras técnicas estatísticas é a presença de censura, que ocorre quando o evento de interesse não é completamente observado.\n\n### Censura intervalar\n\nA censura intervalar ocorre quando o tempo exato do evento não é conhecido, mas sabe-se que ele aconteceu dentro de um intervalo de tempo. Isso é comum em estudos médicos, nos quais os pacientes são avaliados periodicamente e o evento pode ter ocorrido entre duas consultas. Modelos tradicionais de Análise de Sobrevivência, como Kaplan-Meier e modelos de riscos proporcionais de Cox, não são adequados para lidar com esse tipo de censura, sendo necessário utilizar abordagens específicas, como as curvas de Turnbull e a extensão do modelo de Cox para censura intervalar.\n\n### Passo a passo\n\n#### Preparo do ambiente\n\nPara realizar a análise, utilizamos o R e carregamos os pacotes necessários para manipulação de dados e modelagem estatística.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carregando os pacotes necessários\n\nlibrary(tidyverse)   # Pacote para manipulação e visualização de dados\nlibrary(survival)    # Pacote para análise de sobrevivência\nlibrary(icenReg)     # Pacote para análise de sobrevivência com censura intervalar\n```\n:::\n\n\n\n\n\n#### Obtenção dos dados sintéticos\n\nCriamos um conjunto de dados sintético com 600 indivíduos e algumas variáveis de interesse, como uma variável categórica, uma variável contínua e o tempo até a ocorrência do evento de interesse. A construção dos dados leva em consideração a influência das variáveis na probabilidade de o evento ocorrer.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 600 # Número de indivíduos na base de dados\n\n# Número de observações por indivíduo, variando entre 2 e 5 observações\nobs_por_individuo <- sample(2:5, n, replace = TRUE)\n\n# Expandindo os IDs para refletir múltiplas observações por indivíduo\ndados <- data.frame(\n  ID = rep(1:n, times = obs_por_individuo)\n)\n\ndados <- dados %>%\n  mutate(\n    # Variável categórica exemplo (var_cat)\n    var_cat = rep(sample(c(0, 1), n, replace = TRUE), times = obs_por_individuo),\n    \n    # Variável contínua exemplo (var_cont), que possui dependência da variável categórica\n    var_cont = unlist(lapply(var_cat, function(s) {\n      if (s == 1) {\n        sample(5500:8000, 1)  # Valor para 'var_cat' igual a 1 \n      } else {\n        sample(1800:3500, 1)  # Valor para 'var_cat' igual a 0 \n      }\n    })),\n    \n    # Idade atual dos indivíduos, gerada aleatoriamente entre 0 e 10 anos\n    idade_atual = unlist(lapply(obs_por_individuo, function(x) runif(x, min = 0, max = 10))),\n    \n    # Risco do desfecho com base em 'var_cat' e 'var_cont'\n    risco_desfecho  = 0.2 + var_cat * (-0.4) + var_cont * 0.0001\n  )\n# Gerando a variável 'desfecho' a partir do risco, usando 0.5 como valor de corte\ndados = dados %>% \n  mutate(desfecho = ifelse(risco_desfecho>0.5,1,0)) %>% \n  select(-risco_desfecho) # remove o risco\n```\n:::\n\n\n\n\n\n#### Transformação em dados de sobrevivência\n\nOs dados brutos precisam ser transformados em um formato adequado para análise de sobrevivência com censura intervalar. Criamos as variáveis left (limite inferior do tempo do evento) e right (limite superior do tempo do evento), bem como a variável de censura (cens), que indica se o evento foi observado (1) ou censurado (0).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_surv = dados %>% \n  group_by(ID) %>% \n  summarise(\n    left = ifelse(\n      any(desfecho == 1),\n      max(idade_atual[idade_atual < min(idade_atual[desfecho == 1], na.rm = T)\n                      & desfecho == 0], na.rm = T),\n      max(idade_atual) # Caso não tenha ocorrência do evento, a maior idade é registrada\n    ),\n    right = ifelse(any(desfecho == 1),\n                   min(idade_atual[desfecho == 1], na.rm = T),\n                   NA), # Caso o evento não tenha ocorrido, substitui por NA\n    cens = ifelse(any(desfecho == 1), 1, 0),  # Indica se o evento foi observado (1) ou censurado (0)\n    var_cat = first(var_cat),   # Variáveis de covariáveis para análise\n    var_cont = first(var_cont)\n  ) %>% \n  ungroup() %>% \n  mutate(left = ifelse(left < 0, 0, left))  # Garante que 'left' não seja negativo\n```\n:::\n\n\n\n\n\n#### Curvas de Turnbull\n\nAs curvas de Turnbull são uma extensão do estimador de Kaplan-Meier para dados com censura intervalar. Implementamos uma função para calcular o vetor de tempos ótimos (tau), estimar a função de sobrevivência inicial e iterativamente atualizar as probabilidades de sobrevivência até a convergência do algoritmo.\n\nComparamos as curvas de sobrevivência entre dois grupos da variável categórica para verificar diferenças na distribuição do tempo até o evento.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Função para criar o vetor de tempos (tau) a partir dos intervalos censurados\n# O uso de digitos de arrendondamento é contribuição de Sofia Aguiar \n# a fim de evitar erros em bases meiores que 10 mil\ncria.tau <- function(data, digits = 6) {\n  l <- data$left\n  r <- data$right\n  \n  # Arredonda os valores para evitar pequenas diferenças numéricas\n  l <- round(l, digits = digits)\n  r <- round(r, digits = digits)\n  \n  tau <- sort(unique(c(l, r[is.finite(r)])))  # Combina os tempos de censura\n  return(tau)\n}\n\n# Função para inicializar a função de sobrevivência com base no vetor tau\nS.ini <- function(tau){\n  m<-length(tau)\n  ekm<-survfit(Surv(tau[1:m-1],rep(1,m-1))~1)\n  So<-c(1,ekm$surv)\n  p <- -diff(So)\n  return(p)\n}\n\n# Função para construir a matriz A de intervalos de censura\ncria.A <- function(data,tau){\n  tau12 <- cbind(tau[-length(tau)],tau[-1]) # Cria os intervalos [tau[i], tau[i+1]]\n  interv <- function(x,inf,sup) ifelse(x[1]>=inf & x[2]<=sup,1,0)\n  A <- apply(tau12,1,interv,inf=data$left,sup=data$right)\n  id.lin.zero <- which(apply(A==0, 1, all)) # Matriz de censura\n  if(length(id.lin.zero)>0) A <- A[-id.lin.zero, ] # Filtra intervalos não observados\n  return(A)\n}\n\n# Função de Turnbull, que realiza a estimação iterativa da função de sobrevivência\nTurnbull <- function(p, A, data, eps=1e-3,\n                     iter.max=200, verbose=FALSE){\n  n<-nrow(A)\n  m<-ncol(A)\n  Q<-matrix(1,m)\n  iter <- 0\n  repeat {\n    iter <- iter + 1\n    diff<- (Q-p)\n    maxdiff<-max(abs(as.vector(diff))) # Diferença máxima entre iterações\n    if (verbose)\n      print(maxdiff)\n    if (maxdiff<eps | iter>=iter.max)\n      break\n    Q<-p\n    C<-A%*%p\n    p<-p*((t(A)%*%(1/C))/n) # Atualiza as estimativas de probabilidade\n  }\n    cat(\"Iterations = \", iter,\"\\n\")\n    cat(\"Max difference = \", maxdiff,\"\\n\")\n    cat(\"Convergence criteria: Max difference < 1e-3\",\"\\n\")\n  dimnames(p)<-list(NULL,c(\"P Estimate\"))\n  surv<-round(c(1,1-cumsum(p)),digits=5)\n  right <- data$right\n   if(any(!(is.finite(right)))){\n    t <- max(right[is.finite(right)])\n    return(list(time=tau[tau<t],surv=surv[tau<t]))\n  }\n  else\n    return(list(time=tau,surv=surv)) # Retorna a função de sobrevivência\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estimação da função de sobrevivência para 'var_cat' igual a 0 e 1 \ndat1 = df_surv[df_surv$var_cat == 0,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb1 = Turnbull(p, A, dat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIterations =  37 \nMax difference =  0.0009743063 \nConvergence criteria: Max difference < 1e-3 \n```\n\n\n:::\n\n```{.r .cell-code}\ndat1 = df_surv[df_surv$var_cat == 1,]\ndat1$right[is.na(dat1$right)] = Inf\ntau = cria.tau(dat1)\np = S.ini(tau = tau)\nA = cria.A(data = dat1, tau = tau)\ntb2 = Turnbull(p, A, dat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIterations =  40 \nMax difference =  0.0009674135 \nConvergence criteria: Max difference < 1e-3 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualização das funções de sobrevivência para os dois grupos\npar(mfrow = c(1, 1))\nplot(tb1$time, tb1$surv, col = \"#C97064\", type = \"s\", ylim = c(0, 1), xlim = c(0, 10),\n     xlab = \"Tempo em anos\", ylab = \"S(t)\")\nlines(tb2$time, tb2$surv, col = \"#68A357\", type = \"s\")\nlegend(7.5, 0.9, lty = 1, col = c(\"#C97064\", \"#68A357\"), c(\"Categoria 0\", \"Categoria 1\"),\n       bty = \"n\", cex = 0.9)\n```\n\n::: {.cell-output-display}\n![](survival-analysis_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n#### Extensão do modelo de cox para censura intervalar\n\nO modelo de riscos proporcionais de Cox é amplamente utilizado em análise de sobrevivência, mas precisa ser adaptado para lidar com censura intervalar. Utilizamos o pacote icenReg para estimar os coeficientes do modelo de Cox estendido para censura intervalar. Ajustamos modelos univariados e multivariados para identificar quais variáveis estão associadas ao tempo até o evento.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = max(summary(df_surv$right))  # Máximo dos valores de censura\nli = df_surv$left \nui = ifelse(is.na(df_surv$right), m + 1000, df_surv$right)  # Ajuste para censura direita\n\n# Ajuste do modelo de Cox para a variável categórica\nfit1 = ic_sp(cbind(li, ui) ~ var_cat, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n        Estimate Exp(Est) Std.Error z-value         p\nvar_cat   0.4066    1.502   0.09684   4.199 2.687e-05\n\nfinal llk =  -955.6242 \nIterations =  62 \nBootstrap Samples =  100 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Ajuste do modelo de Cox para a variável contínua\nfit2 = ic_sp(cbind(li, ui) ~ var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cont, data = df_surv, model = \"ph\", \n    bs_samples = 100)\n\n          Estimate Exp(Est) Std.Error z-value         p\nvar_cont 0.0001526        1 2.274e-05   6.709 1.963e-11\n\nfinal llk =  -943.4134 \nIterations =  53 \nBootstrap Samples =  100 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Seleção das variáveis com p-valor < 0,25 para a análise multivariada\nfit3 = ic_sp(cbind(li, ui) ~ var_cat + var_cont, model = 'ph', bs_samples = 100, data = df_surv)\nsummary(fit3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nModel:  Cox PH\nDependency structure assumed: Independence\nBaseline:  semi-parametric \nCall: ic_sp(formula = cbind(li, ui) ~ var_cat + var_cont, data = df_surv, \n    model = \"ph\", bs_samples = 100)\n\n           Estimate Exp(Est) Std.Error z-value         p\nvar_cat  -2.5350000  0.07923 3.350e-01  -7.570 3.753e-14\nvar_cont  0.0007336  1.00100 7.532e-05   9.741 0.000e+00\n\nfinal llk =  -917.3918 \nIterations =  56 \nBootstrap Samples =  100 \n```\n\n\n:::\n:::\n\n\n\n\n#### Seleção de variáveis \n\nPara selecionar as variáveis mais relevantes, utilizamos um procedimento iterativo baseado na log-verossimilhança. Variáveis com baixa contribuição para o modelo podem ser removidas para simplificar a interpretação dos resultados e reduzir o sobreajuste.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep_icph <- function(model, data) {\n  vars <- attr(terms(model$formula), \"term.labels\")  # Variáveis do modelo\n  current_model <- model\n  best_llk <- current_model$llk  # Log-verossimilhança inicial\n  \n  # Processo iterativo de remoção de variáveis com base na log-verossimilhança\n  for (var in vars) {\n    formula_new <- as.formula(paste(\"cbind(li, ui) ~\", \n                                    paste(setdiff(vars, var), collapse = \" + \")))\n    model_new <- ic_sp(formula_new, model = \"ph\", bs_samples = 100, data = data)\n    new_llk <- model_new$llk  # Log-verossimilhança do novo modelo\n    \n    # Diagnóstico e atualização do modelo\n    if (new_llk > best_llk) {\n      best_llk <- new_llk\n      current_model <- model_new\n      vars <- setdiff(vars, var)\n    }\n  }\n  \n  return(current_model)  # Retorna o modelo final\n}\n```\n:::\n\n\n\n\n\n### Conclusão\n\nA análise de sobrevivência com censura intervalar permite estudar fenômenos nos quais o tempo exato do evento é desconhecido, mas delimitado dentro de um intervalo. O uso das curvas de Turnbull e da extensão do modelo de Cox para censura intervalar são ferramentas fundamentais para extrair informações valiosas desses dados. A seleção cuidadosa de variáveis melhora a precisão dos modelos e ajuda a compreender os fatores que influenciam o tempo até o evento de interesse.\n\n\n### Referências\n\nANDERSON-BERGMAN, C. icenReg: Regression models for interval censored data in R. Versão 2.0. Disponível em: <https://cran.r-project.org/package=icenReg>. Acesso em: 19 dez. 2024\n\nCOLOSIMO, E. A.; GIOLO, S. R. Análise de sobrevivência aplicada. Blücher, 2024.\n\nSUN, Y. Survival data analysis with interval-censored data. Statistics in Medicine, v. 25, p. 3563-3578, 2006.\n\nTHERNEAU, T. M. survival: Survival Analysis, Including Penalised Likelihood (versão 3.4-0). 2023. Disponível em: <https://cran.r-project.org/web/packages/survival/index.html>. Acesso em: 16 dez. 2024.\n\nTURNBULL, B. W. The empirical distribution function with arbitrarily grouped, censored and truncated data. Journal of the Royal Statistical Society, v. 38, p. 290-295, 1976.\n\n",
    "supporting": [
      "survival-analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}